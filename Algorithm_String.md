# String

* String s1 ="abc";
* String s2 = new String("abc");
* String s3 = "abc";
  * s1==s2  false (S2 -> Heap에 레퍼런스 저장)
  * s1==s3  true (literal pool 사용 "abc"레퍼런스 동일)



* 스트링 생성자에 char[] , byte[] 을 String 으로 만들어주는 메서드 존재
* 스트링 값 비교 => s1.equals(s2)

Stringbuffer => String 조작 가능

- Character.isDigit ( 숫자인지 아닌지 판별 /숫자면 true)
- 확장 문자열 Char 배열 초기값  **'\u0000'** (공백 문자(스페이스))
- Integer.toBinaryString  (부호비트 값만 출력 (앞에 0 출력x)
- Integer.parseInt(str.substring((0,1),2)) ( String str 0부터 1까지 2진법으로 인식 하여 int형 반환)



#### 라빈 - 카프 알고리즘

---

* 문자열 검색을 위해 해시 값 함수를 이용
* 일일이 비교하는 대신 패턴의 해시 값과 본문 안에 있는 하위 문자열의 해시 값만 비교
* 속도 빠름 ( O(MN))

* 고려사항
  * 처음 해쉬 값을 구할 때는 찾고자 하는 문자열에서 패턴 길이 만큼 읽어 구한다
  * 해쉬 값이 일치하더라도 실제 패턴이 일치하지 않을 수 있기 때문에 문자열 일치를 검사해야 한다 ( 해쉬 충돌)

#### KMP 알고리즘

---

* 불일치가 발생한 텍스트 문자열 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
* 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
  * next[M] : 불일치가 발생했을 경우 이동할 다음 위치
* 시간 복잡도 : O(M+N)

#### 보이어-무어 알고리즘

---

* **오른쪽에서 왼쪽으로 비교**
* 상용 소프트웨어에서 채택하고 있는 알고리즘
* 패턴에 오른쪽 끝에 있는 문자가 불일치 하고 이문자가 패턴 내에 존재하지 않는 경우, 패턴길이 만큼 이동



#### Trie

---

* 문자열의 집합을 표현하는 트리
* 각 간선은 하나의 문자에 대응하며 같은 노드에 나오는 간선들은 같은 라벨을 갖지 않는다
* 각 문자열은 단말(leaf) 노드에 대응한다

* 부분 문자열 검사 가능
* 두개의 접미사의 최장 공통 접두사
* 사전적 순서로 정렬된 K번째 접미사 찾기